# 2021年学习日报

# 2021年1月1日


1. 泡在宿舍复习计网，目前复习到数据链路层，写了点复习题
2. 可恶，本来想看xpose视频的，机器码上次忘记给珍惜表哥，可能要等3号了
3. 重温了一些协议分析的文章，发现都是比较常规的做法，比如先抓包，然后jadx中
搜索其中的字段，找到这个字段是如何生成的，运用了什么算法，不断的查看引用，这种
可以避免那种很恶心的0o混淆，一般最后的大逻辑，是在native层，先看.init array段
和jni_onload方法，查看是否有反调试，以及动态注册registerNative方法中的参数
，最后找到真正的native函数，这里有取巧的方式，比如利用frida-rpc，将手机上当成一个
远程服务，本地调用native的函数，直接生成，要不就是逆向分析进去，然后本地复现加密算
法。目前看的还没有非常强的混淆，还有抓包干扰，其实抓包名堂都挺多，还是得多分析，
遇到一个问题就是碰到一些分析文章，但是无样本实战，有点难过

# 2021年1月2日

1. 计网数据链路层复习完了
2. 和阿里15年的一道反调试的题，杆上了，一attach上就直接闪退，明显有反调试，在.init.array段没看到什么动静，说明动手脚的一般就在jni_onload上了，跟进去发现里面代码有点乱，可能有啥别的操作，反正逆向只需要关注主要功能在哪，这个下断，至少卡了我八个小时，最后发现是我真机有问题（mmp，之前也只是听过，实操没弄过，这次搞，也遇到不少坑，首先jni_onload执行是比其他so函数要早的，所以我们得在so加载进来的最开始停下来，像常规的直接attach，在jni函数下断点不好使了，这里得换成用命令行的adb shell am start -D -n com.yaotong.crackme/.MainActivity，先以调试模式启动，（当然前提是然后先用androidkiller在Androidmainfest.xml中添加个android:debugger=true，），然后这里常规方式attach上去，真机选择androidlinux，模拟器使用linux server，模拟器就算了吧，搞到后面没执行权限（mmp，然后设置一下常规的三个debugger option，然后这里ddms有两种操作，一种是直接打开monitor，观察蜘蛛颜色，另一种是命令行的端口转发，然后在命令行中jdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8700，出现的窗口全部cancel掉，然后f9运行，ctrl+s找到so加载的基地址，加上偏移，下个jni_onload的断点，剩下就是慢慢单步动调了，发现有个跳转，一运行就闪退，明显问题出在这里，我看很多人的操作是直接nop了，也没跟进去，甚至直接修改了硬编码，重打包，万一后面还有反调试怎么办，应该是在动调中，先patch，然后一步一步到结束，几个反调试的地方，再进行硬编码的nop，估计很多也就是直接照搬小黄书了。 坑的是，我真机ddms弄不了，monitor也查看不到，太扯了，打算刷刷机
# 2021年1月3日

1. 数据库文档和项目提交了
2. 通过珍惜表哥视频，入门了一波xposed，学习了常见的api，毕竟少了
so层的hook，感觉还是蛮容易的，不过机子得刷Edxposed来进行插件管理
，然后开启插件，让插件生效，frida和xpose核心思路很类似，所以
理解起来也没有什么困难的，然后就是学习了一波实战方向定位关键代码的
知识，总体来说，两个方向，一个是打印栈信息，另一个是关键词搜索，
珍惜表哥也秀了一波他的小工具，打印出所有加密算法的xposed插件，
我看了下，应该就是hookjava层的加密api，然后把参数和返回值，以及
栈信息保存在sd卡中，还引出了利用ddms的view按钮，查看view的id，
找到onClick方法，之前没接触过，算是见识了，总体来说，收获还是挺
大的，把笔记都记到网易云上了，还蛮方便的，2333
3. 学弟最近在学爬虫，我正好打算重新学一波高阶爬虫，顺便寒假教给学渗透的，
给他们提升实力，当然现在肯定没时间了2333，要等我考完了

明日计划:
1. 计网复习
2. 机子刷入edxposed和mt管理器
3. 复习简历上的东西
# 2021年1月4日

1. 去哪儿网面试结束，感觉有点紧张，发挥的很一般，认识了团队的leader mike哥，mike哥说看到我的潜力，
我感觉特别感动，不能辜负mike哥，得更加努力的学习才行，另外重新复盘反思了一下自己没答上来的问题，
发现自己目前欠缺在语言特性记得不是很牢固，尤其是c++，还有就是实战分析app经验太少，等考完期末考，
得好好补补，多输出点干货
2. edxposed还没装好，估计是我科学上网有问题，magiskmanager一直刷新不出来，下载模块搜索
riru，直接没有，应该是我没科学上网成功，可恶，刚买的vip，明天再问问克服，mt管理器比较好装
，apk百度一搜，直接adb install装，挺好用的，可视化的功能强大文件管理器。
3. 因为xpose环境还没装好，学习视频xposed native暂时放下了，等装好了再继续
就换了个dex解释执行和1234代壳特点讲解视频学习，dex解释执行，得从dex所用的dalvik-bytecode入手
，因为art虚拟机中的c++实现的解释器，是根据dalvik-bytecode中的每一行的操作码，来进行解释执行，
标准的while+switch，12代壳能明白，因为自己也实现过，3代类抽取的是主要对codeitem动手脚，这里
感觉还是得自己实现一遍印象深刻些，下节视频就是简单实现了，期待一会，4代的vmp，5代的java2c（
java层函数全部native化）算是有个大概的认识，至少碰到了可以知道是几代加固了2333
4. 参加了学院的迎新晚会，上台作为优秀学生代表上去为我们工作室领了个奖（竞赛拿奖的表彰），还是挺开心的，今晚迎新晚会
举办的很成功，很精彩，工作人员都辛苦了！
5. 准备把xpose环境装好，就好好复习了，就剩6天了，加油冲
# 2021年1月5日

1. 把edxposed的环境终于刷进去了，昨天熬到两点都没弄出来，今天百度和问了几个师傅，总结下坑点:
    - 在线安装最新版的面具是有bug的，无法搜索riru-core模块以及本地安装riru-core模块也无法安装，
    所以我解了bl锁，然后重新卡刷了一个低版本的面具
    - 卡刷不要将zip放到/sdcard目录下，亲测是会乱码的，因为卡刷是要用自己的内存卡的，解决方式就是直接将zip push到/data/local/tmp下面
    - 将刷机的过程记录到博客上了，链接如下:
    https://www.cnblogs.com/YenKoc/p/14236792.html
2. 当用了很多时间，把事情搞定的时候，感觉特别的爽，剩下时间就得留给期末复习了，挂科是不可能
挂科的，嘿嘿
# 2021年1月6日

1. 早上起晚了，洗了衣服，开始看xposed native的视频，发现这玩意对so加载流程和c++要求蛮高的，大概把原理弄懂了，大概就是hook java层的dlopen（不同安卓版本hook的加载函数有区别），加载app本身的so文件时，也把我们的so文件，通过inlinehook，将原本要hook的native的函数指针，指向我们的so文件函数指针，里面是通过查看map，找so的基地址的，好多细节工作没讲到，只明白了大概的hook流程，之后会有实战视频好像，期待一下，so加载流程明天得补补，还有c++安排上
2. 类抽取的方案原理看了四哥的文章，其实就是通过将code_Item结构体下面的ininst字段赋值为零，那个字段是dalvik的bytecode，我在想，如果把code_data_off给弄成0，效果应该也是一样的，毕竟只是类的信息，那些反编译工具无法识别了，然后至于解壳的话，就是通过dexfindclass方法，将原来字段值填入，这里其实我不是很理解，还在查
3. 计算机网络继续复习，复习到网络层了，今晚应该能结束网络层

# 2021年1月7日

1. 计网还在复习当中，今天应该能结束了，然后复习概率论

# 2021年1月8日

1. 今天看雪的高级研修密码学部分看了四集，大概4个小时，rc4理论加实践，ollvm混淆之后的rc4（一级混淆）的识别方式，以及aes以及des的理论知识，以及java层和native层的实现，但是没加ollvm混淆，估计后面几节会开始讲的，总体来说，rc4的理论会比较简单，识别的方式也挺明显的，s盒的初始化，以及密钥的拓展，都是256次的循环，以及后面的打乱s盒子，都是256次循环，尤其是最后的密钥流和明文进行的逐位异或，根据这些特征进行识别，之后经过ollvm混淆过的，明显就丑很多了，但是混淆级别不是很高，可以慢慢跟程序的流程，然后还是可以看出rc4的特征来的，frida native直接安排上，将密钥和明文都给hook上，过程中遇到一些bug，就是pixel架构是64位的，而我看的so文件的偏移是32位的，之所以我看32位是寒冰也看32位。。，忘记了他之前安装app时，选择的架构就是32位的，大意了，改正一下，成功主动调用hook上了，后面的打印key的时候，由于ollvm混淆有字符串加密，需要我们hook的点，要在加载so文件之后，再进行hook，这里也是hook了System.loadLibrary中的loadLibrary0方法，执行后再hook，再次感觉必须对linker的源码要非常熟悉才行！，aes和des可能是原理比较复杂，寒冰也没很细说，其实我觉得也没必要细说，因为代码量挺大的，完全记住几乎不可能的，所以根据他们的常量表进行识别是最快捷的，然后觉得是哪种加密，再去github上找源码对照的，基本是可以确认下来的，ida的find-crypto插件也都是利用这种匹配的方式进行查找的，代码量少的，绝对可以直接看出来的，如果没混淆的情况下，笔记都记在云笔记上了，感觉还不错
2. 明天早上看两集，然后复习！！！
# 2021年1月9日

1. 密码学把aes和des填充模式以及工作模式搞清楚了，然后实战方面，发现java层的原理，本质还是hook java层的api，然后实现关键代码的栈信息打印，然后把key和iv，加密用的加密模式，全可以hook出来，自己写个珍惜表哥的加密算法打印应该也是可以的。
2. 概率论复习完第一章，并把习题写了一遍，发现好多都是高中知识。

# 2021年1月10日

1. 概率论复习，太痛苦了，两天学完，😭，现代教育技术复习，背书ing
# 2021年1月11日

1. 计网复习加概率论复习，惨兮兮
# 2021年1月12日

1. 计网和概率论复习完成，准备考试
# 2021年1月13日

1. 两门最烦人的考试终于考完了，剩下数据库复习两天
# 2021年1月14日

1. 数据库复习，明天考完
# 2021年1月15日

1. 期末考试终于结束了，要准备好好搞技术了
2. 跟着视频重温了一波arm汇编，虽然感觉讲的挺水233
3. 看了一下知乎上的路线图，发现有些知识回想起来还是缺失的
，所以之后学习，可能会改变下学习策略。
# 2021年1月16日

1. 重温了一波smail语法，以及log注入，在smail中关键代码处插入打印函数调用堆栈，
androidkiller比较智能，右键是可以直接插入的，然后在ddms中，查看打印日志
就可以直接定位关键代码处了，然后重打包之后，常规操作，之后就是看到一波elf调用本地
so库的操作，感觉挺好玩的，这样的话，可以白嫖别人的so文件，然后调用它的函数，这样不就可以把它的协议给抠出来吗，简单粗暴，百度了一番，发现很多资料非常老，而且不靠谱，找了很久，才找到能实现的，目前仅仅只能实现调用本地库，只能自己本地编译so库，然后再调用，还没学233，写了篇博客记录了下做法:https://www.cnblogs.com/YenKoc/p/14287957.html
2. 看了几篇linker的源码分析，对System.load(so文件名)这个过程更加了解了，感觉可以冲一波xposednative了，感觉我又活了，明天再看看我导师的视频，加深加载流程的理解，并实际跟一波源码
3. 今天到家了，路上花了比较多时间，在高铁上也挺无聊，拿着ipad翻了翻程序员自我修养，感觉又了有些新的思路学习  
# 明日计划:
1. 导师视频so加载流程，并实际跟源码，并记录
2. 2期视频继续跟，打打基础
3. xposed插件撸点出来
# 2021年1月17日

1. 把导师的关于so文件结构以及so加载流程的视频看完了，感觉写的不是细，另外把程序员自我修养和csdn的博客再看了一遍，感觉大致的过程就是dlopen->dl_dlopen->find_library(返回soinfo结构)|调用构造函数->find_library_internel-等，过程还是挺繁琐的，大致了解了为什么.init,.init_array会比jni_onload先执行了。
2. 2期视频看完了签名验证部分，都是本地验证，实际上现在很多都是服务器验证，还是很多手法要学的。
3. xposed鸽了，大意了，忘记把pixal的数据线带过来了，明天得去买根，回来就冲

# 明日计划
1. 安卓四大组件再重温下，然后自己写个demo，测试下之前学的bypass手法

# 2021年1月18日

1. 上午补办身份证装宽带，下午被老妈拖去逛街，晚上给学弟们培训了下，计划直接鸽了，裂开
# 明日计划:
1. 安卓四大组件再重温下，然后自己写个demo，测试下之前学的bypass手法，别鸽了
# 2021年1月19日
1. 把java层和native层的签名验证都写完了，还重温了一下native的开发，发现native的特点就是繁琐，尤其是调用java层的方法，更是如此，然后在本地bypass了，测试了下，发现一个问题是强度不太够，目前有看一些是用签名做key来进行加密，传送到服务端验证的方式，不是简单的进行对比，目前bypass的手法总体来说是smail注入以及人工patch，要么就是用hook libc的方式，直接将返回值返回成正确签名值，然后服务端的签名验证算是强度比native验证更高一级了，最终还是得分析出协议的算法，以及签名在其中担任是什么角色，再进一步的对抗。
2. c++还是太弱了，刚好pixtel的数据线没买到，打算从window逆向重新玩玩，加强逆向和语言开发能力。

# 2021年1月20日

1. 找csapp再继续看了，重温了下，手机数据线还没到，重新把window的环境给搭好了，vc6也安排上，文艺复兴下，把去年没学完的知识再巩固下，c++继续加强。

# 2021年1月21日

1. 把之前滴水没看完的视频看了5节，海哥讲的很好，就是时间太长了，2倍数也挺慢的，不过感觉还是有收获的，比看书有意思
2. c++就跟着b站的视频学了，看看撸几个项目，然后开始看c++ primer，继续冲

# 2021年1月22日

1. b站上c++的视频讲的真的很不错，开个2倍数，看了三分之一，晚上的wifi网速真的慢，不知道为什么，看视频都特别慢，严重拉慢了我的学习进度，晕，看来白天得多学一点，晚上看书复现为主

# 2021年1月23日

1. ctfshow 大吉大利杯打了一天，本来不想打的，看了下s5表哥也在打，我也跟着玩玩，A了三题，剩下个ue4的虚幻引擎真不知道咋搞，好像是解pak包，然后还有一个三维的走迷宫，太恐怖了，手撸玩不动，还是有几个师傅写出来了，太强了，准备找个wp学学
2. vscode2017似乎之前装错了，发现和黑马的视频上创建项目不一样，有点晕，晚上
太卡了，更新不了，打算重装试试，把项目写完
##  明日计划:  
1. xposed看雪视频学习
2. 黑马的c++项目撸完

# 2021年1月24日

1. 黑马c++基础项目撸完了，放到github上了，准备把黑马三个项目都撸完，果然从底层学上来，理解知识就很快,继续看了十节的面向对象，继续冲核心知识
2. xposed看雪看了两节，第一节是xposed的介绍和安装，了解了下xposed的原理，主要是通过替换/system/bin/app_processs文件控制zygote进程，又因为zygote进程是孵化进程，每次app启动时，都会加载xposed framework的xposedBridge.jar，从而实现对zygote进程以及jvm的劫持和hook,第二节就是xposed hook构造函数，写插件demo，有一套xposed 插件开发的流程，已经记到github上了，相比之下，frida简直太方便了，写个js文件，直接上去hook，xposed插件改动还得重新编译，再把机子重启，还有模块其实对所有app都会有影响，所以需要对包名做区分。
## 明日计划:
1. 陪老妈去医院看个病
2. xposed插件demo编写，视频再继续一节
3. c++继续学习
4. ctfshow 复现下wp


# 2021年1月25日

1. 黑马c++对象特性看完了十节视频，了解了深拷贝和浅拷贝的区别，以及默认构造函数，有参构造函数，拷贝构造函数的调用方法，笔记都写到网易云笔记上了，忘了就可以看一波2333
2. wp复现完了，记录到博客上了，发现自己的算法贼烂，目前也做了一些深度搜索的题目了，但是算法居然还是没写出来，打算去leetcode上找找题目写写。
3. xposed插件直接被我鸽了，丢，主要wp复现太久了。
## 明日计划
1. 给学弟们培训下逆向的基础知识
2. 讲讲pwn的rop，自从换了mac，pwnd的环境都没了，重新搭好，讲几题案例

# 2021年1月26日

1. leetcode的深搜和回溯都写了一题，把回溯算法思想重新看了一遍，都写到博客上了，回溯的话
对找全排列和路径搜索真的是好用
2. pwn的rop都在ctfwiki上看完了，栈的话还是比较熟悉，在靶场上写了些pwn题，还行，不过咋感觉
有点不务正业呢2333.
3. 今天有点个人私事，耽误了点时间，得继续学习了
# 明日计划:
1. xposed继续学习
2. c++继续十节视频

# 2021年1月27日

1. xposed视频看了两节，将笔记都记到github上了，感觉hook的手法和jni好像，后面看了源码才发现原理都是反射
像，是挺正常的2333，还得继续抓紧看，争取在后天就结束xposed
2. c++看了5节视频，还有十几节就可以撸项目了233
3. leetcode dfs+回溯写了一题，感觉对回溯更加熟悉了
4. 今天挺开心的，发生了我现在都不敢想的事，同时也感觉自己技术还需要继续提高，冲冲冲
# 明日计划
1. xposed 三节视频学习，并作笔记
2. c++十节视频

# 2021年1月28日

1. Xposed学习了hook一般函数，主动调用函数，加壳app的hook处理，前两节视频感觉还是挺好理解的，主要就是熟悉xposed的api使用，但是寒冰大佬更多是使用反射来进行教学，所以写的话，就是先写反射再写一遍xposed的api，之前不理解，后来看了xposed的源码以及对加壳app的处理的学习后，发现xposed底层其实也是用反射实现的，不过是把权限处理也给封装了，使用起来更方便，不需要再去管是public还是private了，然后反射这么好用，我个人理解是因为可以很灵活的对java系统框架层的类进行加载，获取方法名，参数之类的，包括加壳app的hook处理，现在很多加壳是通过动态加载并修正classloader的方式进行的，如果我们直接在一开始加载壳app的classloader(也叫pathclasloader)的话，进行查找Class对象是找不到的，因为我们真正要hook的类不在这里被加载，所以处理的方式其实就是在attachbasecontext和oncreate方法执行后，去hook这个ClassLoader，将这个修正后的classloader取出来，对这个classloader进行查找类，并进行hook我们真正的方法，这里感觉需要对安卓源码要很熟悉，以及反射要好好运用，fart里面也全是反射写的，可见反射的重要，打算再看看寒冰佬在看雪上发的文章，以及关于classloader深入理解，顺便写一个java层的算法自吐的xposed模块，进一步熟悉xposed的api。
2. C++学习了友元以及运算符的重载，友元其实就是可以让私有的方法或属性在类外也可以访问，运算符重载其实就是对常见的运算符进行自定义，比如一个对象加一个对象，这个"加"号，我们可以自己通过c++给的api，实现一波定制，然后还发现引用可以实现链式的编程，非常nice
3. 早上在医院陪了我妈一上午，老妈状态也好了不少，应该马上就可以出院了，听到隔壁病床是癌症复发，被推出去做手术了，心里也不是滋味，感觉人生真的好短，一场大病可能会摧毁一个家庭，保重身体，好好珍惜每一天吧！

# 明日计划:
1. 实现java层自吐算法的xposed模块
2. 看寒冰大佬的fart看雪文章，搜索博客理解classloader和dex关系
3. xposed视频一节
4. c++继承和多态

# 2021年1月29日

1. 实现了java层框架层常见加密算法自吐以及栈信息打印的xposed模块，其实就是通过hook
框架层的几个构造函数以及一般函数，将参数以及结果打印出来，主要是锻炼xposed的熟练程度
2. 看了寒冰大佬看雪文章，以及csdn上的几篇关于classloader类加载器的文章，感觉理解了不少，我个人理解是类加载器的类加载，是通过类的全限定名去找字节码文件，生成二进制流，实际上就是找dex文件中有没我们想要的类了，所以动态加载自定义的classloader将内存或者存储器中的dex加载进来，那个dex中类才是我们要实际hook的类，如果xposed直接去hook 加载app的pathclassloader的话，是找不到类的，所以我们要hook 加壳后的app，最重要的是得到真正加载dex的classloader，这里我们要挑选时机，一般加壳app，是需要修正classloader的，否则类没有生命周期，所以我们在application类下的oncreate或attachbase这两个方法下进行hook，通过反射获得当前修正后的classloader，再进行hook
3. xposed视频看了两节，内容主要是xposed native，但是感觉没有讲精髓，就是如何通过定位so文件的内存基址，然后定位到符号地址，inline hook，这个没讲，感觉很可惜，只用两个现成的native hook框架来运行了个demo，看来还得看看这两个项目的源码，再自己实现一个，加油冲
4. c++鸽了，项目写了有点久。。打算先放下，先去弄xposed，搞懂了再说

# 明日计划:
1. xposed native两个框架源码分析
2. xposed指纹检测和简单定制


# 2021年1月30日

1. xposed native的两个native框架都下载本地了，看起来还是有点
小吃力，然后遇到很多不知道的api，各种百度以及查，发现原理的话大概是这样
本身是在System.load这个方法下进行hook，但是这是xposed的bug，无法在这个
方法下进行hook，所以需要到更底层的函数进行hook，这里珍惜和寒冰所选择的函数
不同，珍惜会更底层一点，nativedoload函数，寒冰是Runtime对象的load函数，
这里还会涉及到一个安卓版本的问题，根据不同版本去看源码做下兼容，然后hook之后，
通过反射调用doload函数，将我们自己的so文件加载到内存中去，然后剩下就是
找到两个so文件的地址，以及hook函数的地址，用inlinehook方式实现，具体还是
挺麻烦的，不过和so函数级加密挺像的，珍惜表哥也是用的别人的轮子，不过对elf
文件结构够熟悉的话，还是可以写的，俺还是得努力呀！
2. xposed指纹检测和简单定制视频看完了，笔记记到github上了

# 明日计划
1. 继续看框架源码，尝试实现

# 2021年1月31日

1. 框架源码看的差不多了，再次跪拜珍惜大佬，c++水平很高
，感觉自己目前来说，水平还不够，打算再把c++开发再给练练，
来冲一波轮子
2. xposed检测的话，看了美团技术团队18年的帖子以及github上
也有个xposedchecker的轮子检测，检测的方式大概也就是查是否安装xposedinstall，
以及检测是否有方法是从java变成了native，这里主要是xposed将app_process文件
替换之后，函数的入口，变成了xposedbrige.jar中的函数入口，当函数被hook时，会
先执行jni方法hookmethodnative函数指向，调用native方法xposedcallhandle，这个函数调用再调用java方法handlehookedMethod，所以会出现java方法变成native方法的情况，然后
再检测/system/lib等目录中是否有xposed文件，再故意抛出异常检查调用栈是否含有xposed的api
，再或者就是查看内存中是否加载了xposed的so和jar列表等，常规的检测方式。
3. 2月了，得加油啊！！，xposed剩下个定制，弄完就去搞抓包了！！
# 明日计划
1. 看龙哥的xposed的最后一节视频，看看有没干货哈哈
2. xposed的框架定制以及安卓源码编译研究


# 2021年2月1日

1. 龙哥的那节视频只讲了如何注入so文件，没讲如何实现的实属可惜。。。
2. 安卓虚拟机环境搞了半天，家里网速实属不行啊，有点迷，kali装一半就开始报错，
后面发现是我网络不行，又换成ubuntu16.04来搞，顺利挺多的，目前还是同步
源码中，好多坑。。。百度中


# 2021年2月2日

1. 把虚拟机环境搞好了，然后尝试编译了安卓8.1的源码，大概完整弄下来，花了4个小时多，中间很多warning，问了下，好像没啥关系
，还好磁盘分配的多，不然160多g，直接就爆掉了，鬼知道重装了多少次虚拟机2333，没有继续把驱动
打包成镜像，因为自己的机子不多，怕搞坏了，又得折腾好久，打算等实习再入手一架，再来搞刷机，还想再弄台台式跑源码，
等实习有钱了再说2333。
2. 抓包好家伙直接卡在环境配置上，科学上网弄了好久，mac上关于这方面的软件真的是少，最后找到clashx，感谢志哥
借给我节点让我成功注册了，自己也买了个节点，现在没啥问题了，把代理设置了下，虚拟机里面也可以科学上网了，
明天可以愉快的进行下去了，还把虚拟机网络模式改成桥接了，相当于我虚拟机也连上了路由器，和我本机是同样地位
，也分配了和我本机在同一网段下的ip地址，这样可以互相访问，所以把虚拟机里面的浏览器代理设置成我本机的话，相当于
我虚拟机的流量会流向我本机的机场端口，再通过我本机的机场端口再出去，响应也是如此，就是逆过程而已，感觉挺好玩的
。

# 2021年2月3日

1. 将虚拟机上的burp和charles配置ok了，也做了记录，测试了下没啥问题，http可以抓的到，https因为证书的问题就没东西
，昨晚网太卡了，xposed连模块都搜不到了，淦，所以说回家效率太低了，中间人原理的话，目前是看图解https和肉丝的一篇博客
学的，感觉得需要先对https的原理弄清楚，https等于http+认证+ssl+完整性保护，其实就是对http明文传输以及无法识别通信方
容易被窃取的各种缺点进行加强了，https采取混合加密的模式，先采用非对称加密保护密钥，再使用对称加密实际的内容，提高传输
效率，先访问443端口，服务器返回公开密钥回来，客户端判断这个公开密钥和自己内置的证书是否匹配，然后再用这个服务端密钥加密客户
端的公钥，服务端将用于对称加密的密钥经过公钥加密后，再次传输到客户端，之后双方再使用这个密钥进行对称加密传输。
2. 在看雪看了篇提问帖https://bbs.pediy.com/thread-265121.htm，感觉自己似乎和这位师傅有同样的困惑吧，实际工作中安卓逆向
在做什么，真不太了解，具体等实习的时候才会知道吧，加油加油


# 2021年2月4日

1. 学了一波ssl pinning和客户端证书的hook，以及转化，目前抓https的包问题不是很大
，同时感觉hook的话，需要对系统层真的要很熟悉，有时候通杀的那种脚本，本质是对系统的
api进行的hook，实现一波降纬打击，有时候脚本不能使用了，很有可能是系统的api发生了
变化，这个得去看源码进行分析了，所以说开发还是很重要的，至少需要去懂开发的流程是什么
，用了哪些api，需要获得什么信息，感觉这几天在学习过程中，自己想的一些方法论吧，所以
打算在学xx知识时，把开发一起学了，就算慢一点，但是收获感觉会更大
2. buu上写了4题逆向题，其实就是为了找找手感，写了去年的比赛的题，发现自己比去年确实
进步了，之前连wp都看不懂，现在倒是可以自己完成了，ctf无聊的时候，打打调整下心情还是
挺好的哈哈


# 2021年2月5日

- [x] 1. 大多数的https的包都可以抓了，非常的nice，感觉挺有成就感，至少是迈出了一步，
不过开发一直被搁，这波怪我，这两天陪我妈逛街，浪费些时间。



# 2021年2月6日

- [x] 1. service和contentProvider又重新回顾了一遍，把之前service没写完的博客补完整了，contentprovider重新
写了一篇，service也是由Intent来启动的，不过可以运行在后台，同时还提供了绑定的机制，这样活动也可以调用
service中自定义继承自binder类的对象中的方法，onBinde()我是看到后面才知道原来是为了返回binder对象的，
有点意思，至于内容提供contentProvider这个也是之前被面试问到了，好家伙，原来当时问的权限其实是想问我
普通权限和危险权限,普通权限是系统自动授权的，而危险权限是需要用户手动授权的，都需要在配置文件中进行声明
不过在安卓6以前权限是在安装之前就要同意的，否则不能安装，太真实了，深有体会，安卓6之后推出了运行时权限
不需要在安装时同意所有的权限申请，只要用到该功能时，才会向用户申请, 至于内容提供者没有很难理解，其实就是和接口
没区别，底下封装了数据库的操作，我就奇怪了为什么会涉及表这个东西，看到后面才发现原来是数据库被封装了，所以
我们对别的app进行内容提供者读取，实际就是读取对方的数据库，当然也不一定，因为我看了下核心逻辑，其实就是接口的
用法，只要url（安卓里面指uri）正确，就可以触发逻辑，至于逻辑怎么写，和咱们无关，所以为什么安全呢，就是
这个url不容易被人知道，有特定的路径才能访问的，淦，那要是被逆向出了包名和表名，不照样凉凉，可以任意读取
应用的信息了。
- [x] 2. 看了justtrustme的源码，打算自己也实现一个过ssl pinging的插件，或者魔改一波，正在看ssl pinging检查的开发
逻辑，不过androidstudioi有点迷啊，最近gradle下的好慢，我都已经科学上网了。
- [x] 3. 经过几个组件的重新学习，感觉自己对组件的逻辑漏洞很欠缺，打算补补


# 2021年2月7日

- [x] 1. 看了几个框架如何过ssl pinning的文章以及github上的几个项目源码，发现原理还是hook几个框架使用的api，
确实，毕竟得知道如何开发的，才能知道如何去进行bypass，视频也推进了一节，笔记get，实战了一个xx清单的app，发现
用上objection和瘦xx佬的bypass，结果还是抓不到，后面才知道是被混淆过了，一般计算签名都需要打开文件，所以
肯定会使用file类，所以直接hook file类的构造方法，打印调用栈才定位到关键的地方，不过发现就是代码被混淆了
，直接对比源码发现就是几个api名字改了，直接把bypass源码拉下来魔改，就过了
- [x] 2. ssl pinning的开发框架真的好多，相应bypass的手法也多，但是类似justtrustme也不全，大概4种，瘦舞大佬倒是补充了11种，
两个结合起来玩，比较好，打算把瘦舞大佬和justtrust 做个整合，哈哈，缝合怪就是我（2333
- [x] 3. 接触了一波socket的抓包，感觉计网的东西忘了好多，这样不行啊，得补，一堆坑等着填（


# 2021年2月8日

- [x] 1. 今天发生了一些事，耽误了很多时间，有好的，也有不好的，感觉心态不是很好，还得自己调节下，晚上跑跑步冷静会，
总是会莫名焦虑，希望状态尽快回归，还有好多坑要填呢）


# 2021年2月9日

- [x] 1. 继续看ssl pinning的源码，框架太多，我重点就看了okhttp3的开发流程，发现网上这部分内容真的很少，
要么就是各种copy，原理也没讲，其实这部分要从https的证书校验开始说起，肉丝那部分也没讲细，其实流程
是这样的，先往服务端的443端口发送请求，服务端返回一个证书回来，然而查了很多博客，发现这个证书不仅
是一个证书，而是一个证书链，上面有根证书以及中间证书以及真正的证书，客户端这时候要进行校验证书的时间
是否到期，域名是否正确，然后再通过浏览器或者系统内置的根证书与证书链进行比对，是否含有，如果有的话，
就将证书中的公钥取出来，然后就是和之前一样的流程了，至于ssl pinning目的就是为了防止中间人攻击
，将域名和证书绑定起来，固定使用某某证书，okhttp的话，就是将每个证书的公钥取出来，作一个哈希，求出来的
值，保存到客户端中，到时候验证，是将当前返回的证书公钥取出来，同样作哈希，然后和之前map中存入的域名和
公钥哈希进行比对，看了下主要比对逻辑在CertificatePinner类中的check方法  
```
 public void check(String hostname, List<Certificate> peerCertificates)
      throws SSLPeerUnverifiedException {

    Set<ByteString> pins = findMatchingPins(hostname);

    if (pins == null) return;

    for (int i = 0, size = peerCertificates.size(); i < size; i++) {
      X509Certificate x509Certificate = (X509Certificate) peerCertificates.get(i);
      if (pins.contains(sha1(x509Certificate))) return; // Success!
    }

    // If we couldn't find a matching pin, format a nice exception.
    StringBuilder message = new StringBuilder()
        .append("Certificate pinning failure!")
        .append("\n  Peer certificate chain:");
    for (int i = 0, size = peerCertificates.size(); i < size; i++) {
      X509Certificate x509Certificate = (X509Certificate) peerCertificates.get(i);
      message.append("\n    ").append(pin(x509Certificate))
          .append(": ").append(x509Certificate.getSubjectDN().getName());
    }
    message.append("\n  Pinned certificates for ").append(hostname).append(":");
    for (ByteString pin : pins) {
      message.append("\n    sha1/").append(pin.base64());
    }
    throw new SSLPeerUnverifiedException(message.toString());
  }
```
  如果校验错误，就抛出错误，直接终止通信，会一直提醒证书不对。  

  - [x] 2. 实战了一个某游戏网的app的登陆协议，感觉太容易了，毫无对抗可言，不过倒是打印堆栈这个点，我发现挺重要的
      尤其是找到关键逻辑，objection有bug，堆栈打印不全，淦，还是靠我搜字符串搜出来的，我在想如果混淆了，不是直接
  白给了，native层的函数都直接命令好的，符号表都没去，太感人了，通过比对源码，知道是des，同时key和iv在哪个位置
  直接动调弄出来的，frida也hook了一波，感觉难度不咋的，没对抗，下次找点对抗的样本整.  
  - [x] 3. 重新回顾了一波计网，好久没看，感觉忘了好多，准备进行下一步的抓包学习


# 2021年2月10日

- [x] 1. 快过年了，学习效率再次下滑，2333，看了几篇计网的博客，然后将将socket抓包学习了一波，记录了下笔记
，明天就除夕了，和几位师傅也聊了下天，蛮开心的，预祝新年快乐啦！


# 2021年2月11日

- [x] 1. 除夕难道还有人不学习的吗？2333，学了一波frida对jni层以及libc层的hook操作，发现这些层的代码
都体现到某某so中，jni在liart.so，libc在libc.so，具体在哪个so，要根据源码去看，之前觉得hook
registerNative挺难的，没想到啊，和native hook一摸一样，不过就是要自己去把符号名字和地址
遍历出来，再进行hook，有点意思，感觉学到挺多，操作全记到github上了。
- [x] 2. 除夕快乐！！！！芜湖起飞


# 2021年2月12日

- [] 1. 早上陪老妈去登山，之后回来就开始撸吾爱破解的红包题，第一题是window，加了upx壳，但是有点奇怪，居然没有区段
类似.upx这种，可能有啥操作吧，直接esp定律安排上，看到pushad，就知道这里是保存寄存器状态的（实际上壳就是将
代码以及数据或者两者之一，进行加密，然后在开始执行前，进行自脱壳）所以这步就是执行脱壳的代码，那么有push，那么
必有pop，到时候还是回归到最原始栈中，所以在f8后，在esp那里下了个硬件断点，f9就直接到pop的地方，发现有个大跳转
，跳过去，发现无法dump，靠，但是没事，我在f8过程中，发现经过某个函数后，代码和数据就还原了，所以我直接搜字符串，
找到关键字符串下断点，f9，直接到了关键代码，因为无法dump，所以我纯用od看，慢慢看，发现逻辑很简单的，就是简单的
拼接，和密文比较，第一题蛮简单，第二题是题安卓，先静态看了看，java层发现就是一个native函数check，ida安排上
，发现是静态注册的，看了下逻辑，先是一个rc4加密，然后des加密，不过我用find crypto，根本没搜到，我再看了看
代码，发现它把关键特征什么s盒，密钥全给加密了，运行的时候自解密，我寻思那我动调不就行，好家伙，发现根本断不下来
，连文件都没找到，我怀疑我是机子问题，换了别的app，可以完美运行，看了下jnionload以及init段，并无反调试
，谷歌了几个小时，还是没找到解决方法，离谱，可能有啥操作吧，不然这题也太简单了，有待学习！！
- [] 2. 照着第一行代码上敲了下案例，用frida自吐了HttpUrlConnection的几个参数，并打印了一波堆栈，但是我现在
好奇就是如果将代码混淆，那不是直接无了，但是感觉java层的东西，混淆起来也麻烦，可能还是太菜了，继续学习碰碰
钉子就懂了
- [] 3. 志哥和我说他在搞一些编译以及过root，这点我挺缺乏，机子不够，我老害怕把我那台机子搞坏了，准备再入台测试
机。


# 2021年2月13日

- [x] 1. 吾爱的apk经过20000s表哥的指点，xml中有个字段extractlib是个坑，这个字段设置成false，会默认把so文件放入文件系统，这样就不需要加载so了，难怪没看到有模块加载，大意了，下次多注意配置文件，安卓骚操作还是挺多的，所以这里选择修改下这个字段值，结果我又遇到了坑，androidkiller在我虚拟机上编译出来的apk里面没东西，删和装了几次发现没用，百度了一波，发现apk改之理这个东西不错，更新了下jdk版本，直接修改完，自动重打包，重新运行起来，发现可以attach到模块了，动调了下，发现加密流程挺简单，一个rc4一个base64，靠，不知道是不是见多了，我现在看见算法流程，下意识就能知道用了什么算法，离谱，直接解开，提交成功，还想冲冲吾爱的最后的js题，想ak的，好家伙，第二题好难，各种百度js函数，逆回去，发现不太对，懵了，等wp吧，js不太熟悉
- [x] 2. 跟着视频学了一波frida hook .init_array以及fulao那个apk的调试流程，frida hook .init_array这个其实也是通过熟悉so加载流程，跟着源码去看，不同的系统，里面的实现过程有区别，而是慢慢的我发现hook的意义是对app中间运行的某一状态进行的截取或者修改，所以正向中的开发是很重要的，发现so加载流程最终是调用了call_function这个linker中的函数，而且通过objection发现是导出函数，32位中直接hook linker中的函数就ok了，可以将参数打印出来，同时发现调用函数的虚拟地址，那么我们可以拿调用的so文件的基址，相减得到偏移，这样我们ida反编译后，可以直接定位到关键代码，何况里面很多不都是反调试或者解密的函数吗，意义还是蛮大的。
- [x] 3. fulao那个apk的调试流程，实际上完全体现了从开发出来，从我们要的是图片，先去搜索图片的类是什么，再进一步的hook所有类，再hook对应的方法，打印出调用栈，再进一步找到关键代码，对中间数据进行截取，这步是硬功夫  



# 2021年2月14日
1. 整理了下自己的日报格式，想搞成折叠的形式，搞了好一会，发现效果不咋样，还是自己弄回来了，把时间分割了下，一年一年的来，也简洁一些
2. 继续把ssl socket给学完了，下一节看了下是用网卡和路由器抓包，打算先把步伐放慢些，开始搞点实战，把之前作业都补补，所以晚上就一直在抓一个xx信通的app的登陆包，不知道是不是对抗力度很大，ssl pinning bypass，以及证书的hook，各种尝试似乎没啥用，以为是双向验证，但是hook的dump 证书api，客户端没经过，好奇怪，也没有使用file类算哈希，可能有啥操作，明天问问志哥啥情况，我已经被榨干了2333

# 2021年2月15日
1. 把两个app的登陆抓包搞定了，原来碰到的问题，原来是socket代理设置完后，默认是4个端口，如果使用别的端口通信，就无法抓到包，把通信的端口填入，完美抓到，第二个app是某动，一进去发现就无网络，通过开关vpn，发现关了vpn就可以正常进入，同时设置正常的http代理，发现也没走http代理，也就是说必须绕过vpn检测，百度了vpn检测方法，发现这个检测方法是不定时的检测的，还有其他的检测操作的，后面才在肉丝的星球中找到了另一种检测方法，直接用objection hook这个类，发现有个方法每次点击按钮就会检测，再进一步hook这个方法，打印出调用栈，用frida bypass，就可以正常进入了，还写了篇博客记录:
https://www.cnblogs.com/YenKoc/p/14404410.html
2. 继续把9月的题完成一波，之前看了下ollvm搞不出来，我太菜了，看看重新用frida搞一遍，顺便把n1ctf的题也复现一波

# 2021年2月16日
1. 把9月的题搞完了，第一题是道加了数字壳的apk，类抽取的壳，太菜了，不会手动脱，直接用寒冰大佬的fart脚本脱的，哎，感觉自己脱壳这部分非常拉垮，打算这几天重新学一波加固和脱壳，第二题也是数字壳，脱完发现核心逻辑在so层，加了强度不是很高的ollvm，用frida hook打印出函数的执行流程，很香，然后把参数和返回值都dump出来，发现了常见加解密的算法特征，搞定，第三题是dex2c
，java层的逻辑全用cpp实现了，真的恐怖，不过调用的还是java层的api，所以只需要正常 hook java api就能过了
2. 第二题搞了很久，感觉对ollvm不是很熟悉，之前在ctf中碰到好像更多的是，用别人写好的反混淆脚本，一把梭哈，还得搞一波编译原理，怎么挖的坑越来越多了，晕，继续搞吧，打算这几天先搞加固和脱壳，弄完再继续冲编译原理和unicore
# 2021年2月17日
1. 走向一条从未设想过的道路，不知道之后走向会怎么样，今天
给自己放了一天假，明天要认真学了
# 2021年2月18日
1. 把一代动态加载的加固自己手动撸了一次，感觉太强了，哪怕是几年前的产物，但是感觉设计这种要对安卓app启动的流程要非常熟悉，之前还有些不懂的地方，这次差不多搞清楚了，尤其是之前不理解反射替换mclassloader，跟着源码走了一遍，发现清晰了很多，简要回顾下加固流程，先准备一个源apk，一个壳的apk，壳apk主要负责解密apk，并加载，因为app启动时，会先执行application的attachBaseContext和onCreate方法，所以把脱壳的主要代码放在这里，attach方法主要作用就是通过反射替换mClassLoader为我们自定义的classloader，mClassLoader是组件类加载器，只有这个classloader中加载的dex的四大组件才有生命周期，所以需要替换
，然后onCreate方法就是替换application对象，将application对象删除，然后替换成源apk的application对象，将app控制权，交给了源apk，同时在AndroidMainfest.xml中声明的四大组件，刚好注册，可以正常使用，现在想想感觉真是厉害。
2. 在学习的过程中，看源码真的香，现在写代码不会直接百度这个函数的意思了，而是先去看源码的实现，从系统的角度去做和学，真的就是降维打击
# 2021年2月19日
1. 打算把dump证书的通杀肝出来，重新把socket再细致搞一遍，重新看一遍视频，有点摸鱼，冲冲冲
# 2021年2月20日
1. 重新把三个视频认真看了一遍，发现trace手法真的强，我的思路就是先从开发入手，通过objection进行search class，然后把所有的class全给hook上，看看是哪个api被调用，然后再进一步的，search下实例，再利用wallbreaker打印出实例，查看是否有对应的想要的东西，而且wallbreaker太强了，可以通过字段的十六进制地址，再进行打印，这样就可以将实例的所有内容打印出来，nb，那个证书的dump，妈的，不是作业放的api，我尝试了下，发现没私钥，肉丝的手法只是trace 一遍privatekey，然后又类似上面的手法，找到了证书，但是没讲怎么找的，有点降维打击了。。可能我功力还不够，靠
2. 上面派发了一个测试的项目，开冲开冲
3. 今天认识一个哈工大的大佬，太强了，手脱梆梆企业壳，我直接给跪了，我也得加油呀，冲冲冲

# 2021年2月21日
1. 测试的项目太猛了，不愧是商业的软件，猛的一，感觉对抗强度不是那种普通app能相提并论的，我个人感觉，遇到这种app，不能想着如何逆向bb，然后手撸，首先代码量和混淆是一个问题，这个能劝退99%的人，实际上，要从底层去降维打击，从无法混淆和绕不开的地方做hook才是真的，冲冲，还没搞完呢，加油
2. java层的socket源码分析了一波，把视频看完了，发现一个问题，感觉好像就是socket的抓包呢？emmm，有点东西，打算重新复现看看
3. hgame week3的wp出来了，好家伙，那题安卓好像不难，问题是我安装不上，真醉了，晚上打算复现复现

# 2021年2月22日
1. 好家伙，frida感觉bug还是挺多，现在使用来回在12和14之间横跳，淦，现在implementation还是报错，目前无法解决。。。裂开，看看还弄不弄的了，搞不了就换xposed盘它了，继续研究研究
# 2021年2月23日
1. 好像烦心事还挺多的，这几天失眠好几天了，哎，还是好好搞技术吧，最近都一直在测试，逆一个sm4的算法，看看能不能解密，frida bug最终搞定了），虽然frida14依旧稳定性差，刚好测试的时候，明显感觉自己对frida的使用更得心应手了2333，hook感觉就是一个非常好的动调手法，省事，而且不需要考虑反调试什么的，学了一个webview的file跨域的漏洞手法，挺好玩的，打算测试完，把之后的漏洞都给复现一遍，写文章
# 2021年2月24日
1. 感觉压力还蛮大的，疯狂测试app中，希望有产出！！！，冲冲冲

# 2021年2🈷️25日
1. 熬夜肝到2点，总算再写好了一个报告，有一说一，好多东西要现学是真的爽，就是进度有点慢，继续冲冲冲

# 2021年2🈷️26日
1. 测试测试测试ing
2. 今天坐车来学校，被坑了，这种操作算是我第一次见，也是自己煞笔，没看出来那个人是个演戏的，实际上就是个骗子，也是自己偷懒不去打滴滴，看了价格了，还硬上，实际上好像生活上，很多事情明知道是坑，但是总是各种原因顾虑一直不去拒绝，导致自己一直吃亏，算是被上了一课，这社会是美好的，但是人渣也不少，谨慎，大胆的对侵犯自身权益的事说no
# 2021年2月27日
1. 测试的最后一天，依然是没啥大产出的一天，都是一些小crash，啥时候能遇到高危的洞呀,呜呜呜
2. 写报告冲冲
# 2021年2月28日
1. 晚上出去玩了，庆祝下项目结束
2. 项目总结：第一点感觉自己对应用层漏洞不熟悉，导致测试的时候需要不断的查阅以及判断是否可以利用，即使wiki已经有一些总结，但是不是很详细，往往代码环境是比较复杂的，需要加强这方面的操作，第二点感觉自己做事不够麻利，速度还不够快，需要做到快准狠。第三点，对测试流程不熟悉，一些对接不是做的很好，还是需要多沟通。
3. 打算接下来几天，写一些关于安卓应用层的组件方面安全的文章分享一波，虽然自己对这方面不熟，但是会尽力去学，然后把所学的，用文字表达出来自己的理解。
# 2021年3月1日
1. 在学校办手续中，比较麻烦
# 2021年3月2日
2. 办手续中
# 2021年3月3日
1. 刷一波哈工大编译原理的课，看到2-4，感觉还是有难度的，比较抽象。
# 2021年3月4日
1. 手续提交成功，遇到一点麻烦，问题不大。
# 2021年3月5日
1. 感情上遇到些麻烦，又回归单身了，不想那么多了，还是认真搞技术吧
，明天antctf，争取输出2333
# 2021年3月6日
1. antctf输出还行，先搞了一题安卓二血，算简单的，主要考点就是安卓开发，自定义的application是会先执行的，然后就是发现是动态加载了dex，好家伙，卡在dump 字节流上，不然一血都有可能，python写文件操作还是不熟悉，打算练练写exp的能力，然后就是一题win，挺恶心的，大概动调了大半天吧，发现是每四个字符进行一波操作，输出是固定的，然后想到是通过枚举，然后爆破出来。
# 明日计划
1. 把那题win再继续调调，然后自己写一波exp
2. 安卓抓包继续学习下一章
# 2021年3月7日
1. d3ctf over，输出三题，有一题晚上才看，最后没交上可惜了，那题算简单的了，就各种改eip就很恶心，估计是被虐习惯了，甚至觉得还不够复杂233，wp写完扔github上，复现win那题学到挺多东西的，😄
2. 抓包把socket tcp和udp学完了（x，udp差一点，半夜网络太卡，学不了，明天还有事，打算明天继续。
# 明日计划
1. udp和ssl那部分结束
2. 手续彻底结束

# 2021年3月8号
1. udp和ssl彻底结束，跟着源码撸了一遍，发现是真的爽，这种降维打击，尤其是代码混淆之后，但是始终要调用这个框架层的api，通过打印调用栈实现关键代码定位，udp的比较简单些，毕竟少了一层ssl的通信过程，实际上，通过对开发过程的熟悉，就可以在过程中hook代码状态，得到想要的东西，ssl那部分会更麻烦一点，因为https的通信过程，我再描述一遍，先向服务端443发送一个请求，返回一个服务器证书，证书中有公钥，和本地系统信任的根证书进行比对，通过了就可以将公钥取出，将客户端的公钥通过服务器的公钥进行加密，传送到服务端，在服务端上服务端用私钥进行解密出客户端的公钥，再用客户端公钥对session key进行加密，再传回客户端，所以过程比较多，在跟源码的过程中，发现先建立socket连接，然后对证书进行比对，然后再经过ssl加密传输，和之前的课一样，对sslsocket进行hook，这样就可以在加密前，将原文dump下来，发现最终调用了sslinputstream的write方法，进行hook就完事了，虽然短短几句话，实际上是不断跟源码，查看的
2. 手续已经彻底搞定了，跑了好几个学院，在路上也问了不少的同学，感谢他们233
3. 发现frida对纯elf也可以rpc，这点之前没想过去尝试，昂哥还是厉害，感觉思维比我活跃多了，但是得多学
多整，还有好多东西没学，焦虑ing
4. 在吾爱看到了几篇不错的文章，打算复现一手233
# 明日计划
1. 开始一段新征途了，加油
2. 继续ssl的下一部分
3. 吾爱的dump hook，复现一手

# 2021年3月9号
1. 吾爱的dump hook本地复现结束，延展的看了很多关于脱壳的文章，之前看不懂的一些东西，最近看源码发现有了新的理解，感觉可以继续往下走了，看了无造师傅的一篇fart解析和frida实现，打算再深入学一波fart
2. 昨天太累，ssl直接鸽了，呜呜，明天一定！

# 明日计划:
1. sslsocket下部分，并打印出ip和端口
2. fart深入学习

# 2021年3月10号
1. 又回过头把寒冰师傅的fart文章又看好几遍，加上无造师傅的文章，再结合fart的源码，发现两者的过程还是有不同的，但是思路还是一样的，无造师傅是通过遍历classloader，然后将classloader中的dexpathlist中的element中的dexfile取出来，并取出mcookie，再通过mcookie，可以遍历出所有的类名，然后通过杨神的libart hook，取出artmethod的偏移，再通过artmethod::invoke，进行主动调用，并将codeitem dump下来，进行一波修复，之后遇到artmethod，之前没有碰到过，看了几篇加载的文章，发现其实加载的是dex文件，然后生成的是class对象，中间有artmethod 和artfield的数组，无造师傅的脚本还没搞完，打算再写写，有些地方还是没理解
2. ssl socket下部分结束，没讲什么，就是这个底层的类，无法得到ip和端口，所以往上层hook，并学到了内部类得到本类的实例，使用this.this$0，这个是可以通过androidstudio调试得到的233
# 明日计划:
1. 资产收集
2. fd的抓包环境配好
3. jni层的socket抓包
4. idapython接口了解

# 2021年3月11日
1. 一天的资产收集呜呜
2. fd在kali上环境配置完成，和win上的操作还是有差别，重放找了半天
，发现可以先保存session，然后再重放，证书什么的配置ok，https包也可以抓
，不过fd弊端还是挺大，无法vpn抓包，只要app不走代理，直接无了，青花瓷才是爹
3. 继续把无造师傅的文章，并手抄了一份源码，并抄并理解，结合fart的流程理解，
终于把这个搞懂了，不过按我单独来写，不一定能写出来，唉，代码能力还是得提升，看文章看了好久，不过学到了挺多的。
4. jni socket抓包鸽了。。真没时间了
5. idapython也鸽了。。。
# 明日计划
1. 资产收集
2. jni层socket抓包
3. idapython接口了解

# 2021年3月12日
1. 资产收集ing
2. 无聊就写几题ctf，水了，写了一题安卓水题，直接用objection启动activity就可以，然后就是一题Dectf的题，有一说一xctf的题还是能学到不少东西的，写这题发现是upx，然后无法使用官方命令来脱壳，那么只能选择手脱，有一说一我对win上的东西没有深入研究，百度了几篇博客，直接esp定律，硬件断点一下，f9，然后f8，经过一个大跳转，来到oep，然后利用od的dump插件，直接dump下来，然而居然跑不了，又开始了百度，发现是IAT没有修复，iat又是啥，又开始百度，然后涉及到pe格式，然后我就又开始学pe格式，然后才明白，原来iat是导入表，并且一个iat对应一个dll，里面存储着exe使用外部dll的函数的地址，又看了逆向工程核心原理这节，把怎么把函数地址填补到iat过程也搞清楚了，原来那个data 目录，里面是一个结构体数组，每个结构体中存储着导入的dll名称，以及函数名称和地址，另一个字段存储着iat的首地址，
当要调用时，先加载dll，然后把函数地址全部给导入iat中，我们根据iat首地址加偏移，取得函数的地址，之所以dump下来iat不对，是因为upx加壳的时候，已经将壳的导入表覆盖到exe的导入表了，所以我在想，既然upx是压缩壳，它是自压缩的，那么只要我们能找到适合的dump点，是不是导入表也还原了呢？？ 暂时没找到答案，所以我又卡在了修复iat上，好家伙，困难一个接一个，打算写一个pe解析器，然后把pe格式这块彻底弄清楚，还挺好玩的233，顺便锻炼开发能力
3. 完了，jni层socket一直鸽，裂开

# 明日计划：
1. pe解析器写完，打印出pe格式信息，加强对pe格式的理解
2. jnisocket 抓包
# 2021年3月13日
1. pe解析器撸完，甚至又多做了两个小work，理解了文件从磁盘中加载到内存中的流程，手动模拟加载了一波，新增了一个节区
2. jnisocket抓包上部分结束，好家伙，一些app防止框架层的hook，直接选择在so中，通过系统调用来发包，所以需要hook jni中的api进行dump 流量和溯源，发现就是上节课的send0，是native函数，所以要考虑是不是动态注册的，同时还有一个问题就是native函数是在哪个so里面，这里手法有点没看懂，好像是看mk文件的依赖，然后找到的，剩下就是把so从系统中pull下来，ida来进行分析，xref from，查看调用了libc中的函数，再跟进去，hook就完事了，然后为了防止java层的堆栈和jni层的冲突，所以在frida中加入判断，如果是java层发包，那么堆栈一般是固定的，字符串比对一下，然后纯jni发包，就自然打印出来就好
# 明日计划
1. vnctf准备打一手
2. 然后把抓包再自己复现下，好好理解一下，看看能不能找出objection和这种方式的结合使用方式，加快抓包效率

# 2021年3月14日
1. vnctf打了一手，发现自己算法真不太行，唉，题目意思理解，但是exp没写出来，尤其是dfs，这波算法丢人了呜呜，打算补补，别骂了
# 2021年3月15日
1. filpgame看着师傅的dfs，理解了很久，感觉有点懂了，自己想了个列优先的dfs，算法弟弟
2. 资产收集ing（
# 2021年3月16日
1. 又是资产收集的一天
2. filpgame复现完成，原型就是poj1753的棋盘翻转，原理大概就是枚举2^16次情况，翻还是不翻，我是用bfs写的，dfs也是一样的
3. sandhook研究中，感觉挺好玩的，但是看了原理剖析，把我整懵了，art虚拟机这方面就很弱，打算整本书仔细看看，对理解脱壳也是有好处的，不过目前打算是先把demo写出来，先会用，然后再研究原理，可能效果会更好
# 2021年3月17日
1. 资产收集ing
2. 把pe解析，完整撸完了，感觉对文件格式有了更深的理解，之前一直很担心自己写代码出错，实际上就是一个不断debug的过程，这次写这个解析器，主要收获就是导入表和导出表的学习，简单概述下，导入表，是exe引用外部的dll时，所需要的，因为dll是动态链接库，并不像exe可以不需要担心因为虚拟内存不够，导致加载不到对应的基地址，所以pe中很多地址都是rva，并不是va，方便重定位的，所以在dll加载到内存中时，那么基地址确定，那么va也就确定了，再将exe中的iat填入对应的函数地址，这时候的地址才是实际虚拟地址，同时解析的过程中，也比较麻烦，因为把pe文件拉伸到内存中，并不是加载的状态，而是磁盘形式，放入内存中的，还是以文件偏移为主，所以还需要调整rva转为文件偏移，导出表比导入表更复杂，导出表是有四张表了，一张函数的名字地址表，一张函数名字表，一张函数序号表，一张函数地址表，需要当我们需要调用dll时，查找函数地址，往往就是先根据函数名字，查到函数在函数名字地址表的下标，再通过这个下标，找到函数序号表对应下标里面的值，然后进而找到函数地址，所以导出表也是很重要的，至于重定位表，我理解就是编译器在编译过程中，把地址写死，但是有时候基地址变动时，对应的写死地址，不就有问题了吗，所以需要重定位，把写死的地址减去原来的基地址加上新地址，重新弄进去，写完，感觉收获还挺多的，哈哈
3. 往github上撸了几个sandhook案例，但是构造方法的hook一直有问题，调到2点，还没出来，打算先睡了，明天继续看看
4. 最近莫名焦虑，和李师傅交流之后，感觉自己水平还是太菜，仔细想想还是有很多不足，开发，以及反混淆，企业版加固，这些难点必须要去克服，冲冲冲

# 2021年3月18日
1. 资产收集ing
2. sandhook真的迷，之前用xposed写native hook时候，感觉蛮舒服的，纯sandhook，谷歌了很久，一直没从jni层hook到java层的案例，自己尝试逆向了下crackme1的sandhook的jnionload，大概就是先搜索内存中是否加载了libart.so，然后对art中的ARTClass类进行hook，因为art中是c++写的，java层的每个类在art中也有一个对应的类型，所以去hook了专门的字段所在的地址，然后将该字段的所在的内存空间，读写权限改变，变成了可写，然后将自定义的key进行填充，这样就让原key被覆盖了，感觉挺牛逼的，尤其是对art的类加载和类结构很熟悉，找了几篇博客，跟下了源码，感觉又理解了不少
3. 看一波川大师傅的虚假控制流的反混淆，打算复现下师傅的angr脚本，233，写的蛮清晰的，研究研究。
4. 博客圆居然整改了，开始担心起我的将近400篇的博客，还有几篇博客也没法发了，后悔没用gitpage了，希望博客圆没事）

# 2021年3月19日
1. 资产收集ing，又加一个主域名收集的任务，估计得加班了hh
2. 虚假控制流的ollvm看的差不多了，以及angr的反混淆脚本也撸完了，原理大致是从虚假控制流的表现去反混淆，虚假控制流主要是通过加入不透明谓词，导致编译器和反编译器无法知道值，从而保留这个不透明的谓词，无法优化，同时加入一个不可达的基本块，在这个基本块中，我们可以加入一些垃圾指令和花指令，破坏f5，hh，至于不透明谓词，可以看成一个布尔表达式，混淆器可以知道这个表达式的值，但是编译器和反编译器无法知道，只能在运行的时候才知道这个表达式的值，因为混淆器知道表达式的值所以，程序的正确流程它是知道的，站在开发的角度，程序员也是知道的，站在对抗者的角度，这个表达式只有运行的时候才知道的。然后我们抓住这个特点，可以用angr进行符号执行，先将cfg图通过api遍历出来，然后把不在该函数的基本块去除，避免阻塞，然后，再进行遍历块，进行判读子块数量为2，同时跳转为1，那么则为虚假控制流，直接patch为jmp，这样f5的时候可以进行优化了，自己本地测试了下，很完美，而且用了某大佬的一些工具类，多架构都可以玩了，下一步打算搞搞平坦化，2333
3. 莫名焦虑，加油呀
# 2021年3月20日
1. 去平坦化的流程和原理熟悉了一遍，发现看腾讯之前bird师傅的deflat脚本，发现就是angr一些api不知道什么意思。。有点迷，感觉还得学一手angr的api，不过目前打算直接进军unicore去模拟执行去反ollvm，所以目前调整下学习方式和内容233
2. 资产收集ing
# 2021年3月21日
1. 重新把jni层的抓包熟悉了一遍，跟着源码走了一遍，很舒服，tcp和udp虽然开发的时候使用的api有所不同，但是底层的api都是使用sendto和recvfrom这两个api，不过怎么看源码也是有讲究的，至于在哪个so中，需要去看mk的文件中，源码被编译进了哪个so中，pull下来，ida进行分析，利用ida xref功能，知道了下一层调用的api，就可以一步一步跟到系统调用那里，才是真正的核心
2. 资产收集ing
# 2021年3月22日
1. 资产收集ing）
2. 开始重温下程序员的自我修养，有些概念模糊了，打算再过一遍，看完，再过一遍csapp，就开始搞编译原理了2333
3. 看了下龙哥的jnitrace，感觉还不错，分析分析源码，发发博客

# 2021年3月23日
1. 依旧是一个无情的收集人，不过快结束了
2. 继续重温程序员的自我修养，目前看到70页，睡前看看还挺不错的，明天应该可以学点东西了。

# 2021年3月24日
1. 把jni层的抓包看完了，好家伙jni跟源码下去，发现就是openssl的发包了，和常见的tcp和udp底层最后调用的libc的sendto，recvfrom不同，它这个最后调用是是libc的write和read函数，所以之前hook libc sendto 和recvfrom连密文都没抓到，hh， jni这边openssl，主要hook lissl中的SSL_write和SSL_read这两个函数，再下去就是bio_write函数，再下去就是调用libc的read和write函数了，通过栈回溯去跟流程。
2. 程序员自我修养重温到120页，感觉每次看都有新的感悟，哈哈，非常nice
# 2021年3月25日
1. 感觉发烧了。晕，状态不是很好，回家直接躺着了
2. so加解密实现了一波自修复，真爽，23333
3. 资产收集ing

# 2021年3🈷️26日
1. 晚上10点多，从公司回来，还是不够舒服，就去医院拿了药
2. 资产收集彻底over，还有一些争议的地方，打算再看看
3. 状态不好，写了两篇博客关于so自修复，和apkleaks使用，直接睡了
# 2021年3月27日
1. 回来参加些活动，估计得鸽了
2. 补党员的心得体会三篇，真的多）
# 2021年3月28日
1. 下寝加党员活动
2. 程序员自我修养看到170页，香
# 2021年3月29日
1. 之前思考自己的挖洞的方式，都是从apkpecker上传apk，
然后根据文档暴露的点，进一步逆向，代码审计，如果失去了这个apkpecker，要如何
下手去挖呢，我个人的想法就是先从四个组件开始，先找导出的组件，然后再根据不同组件的特点，去代码审计，比如广播接收器这个组件，我们要担心一个是发送intent是否被恶意的app所拦截，另一个点就是恶意app可以发送恶意的广播去传递恶意的参数，实现越权，主要审计的点就在于这个组件是否做了安全措施，比如只允许自身广播自身接收，使用LocalBroadcastManager.sendBroadcast等等，不过其实核心还是说，人毕竟是干不过自动化的，尤其是这种静态代码去找和分析，有自动化工具作辅助，效率就高很多了，看了好多文章，感觉很有收获
2. drozer安装并使用，感觉很不错，不过看了下有个模块编写，不过国内资料很少）
3. 复现了龙哥的traceNatives，用frida-trace直接trace了so的所有函数，太爽了，不过有点担忧的就是app中触发的点太多的话，感觉流程图会很乱，打ctf还挺不错的，昨天尝试用这个，弄了下上次vn的题，真不错，都trace出来了

# 2021年3月30日
1. 在对某app进行抓包，好家伙，感觉对抗强度真的高，第一个是不走代理，第二个就是vpn检测，过了一个检测网卡的，测了一下午和找了半天，还是没找到其他检测的api，和之前某动过检测不是一个套路，草，感觉厂家如果用自己的一套开发流程去检测，不知道api的话，很难bypass啊，除非是知道某底层api，栈回溯上去。。。沉思。
2. 看了一些arm栈回溯的文章，好家伙，看了一半，发现中间缺了很关键的前置知识，直接裂开了，看了一些crash中探讨arm回溯的原理，先保存image以及exception table entry，保存成minfo结构，然后利用ptrace得到寄存器的值，再利用pc的值进行回溯，打算再观摩观摩，有点可惜啊，写的确实挺不错

# 2021年3月31日
1. 收集了点主域名
2. 复习了一波arm汇编，尤其是跳转指令2333，b是直接跳转，不过存的是相对当前pc值的偏移值，bx，是跳转任意模式的指令，无论是arm模式还是thumb模式，blx，是先将pc当前值存到寄存器r14，然后从arm模式切换到thumb模式，执行thumb指令，之后跳转回来再把r14寄存器的值弄回pc，至于bl，就是blx的过程，去掉了模式切换，有加x的，基本和模式有关系的，其他指令，感觉和x86 x64是大同小异。
3. 把抓包最后一节看完了，感觉干货不多，基本就是先判断是java层还是jni层发包，然后根据调用栈，找到发包逻辑以及加密流程，用frida做rpc，我以为会讲androidnativeemu或者unidgb来模拟执行的，不过给我一点提示就是，通过frida的Java.use得到类对象后，就可以按照java的写法进行本地复现的，尤其frida是可以搜索内存的对象的，直接搜索过来，就可以直接调用它方法的